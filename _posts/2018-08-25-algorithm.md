---
layout:     post
title:      "常用算法实现"
subtitle:   ""
date:       2018-10-25 19:43:00
author:     "wantu"
header-img: "img/post-bg-universe.jpg"
catalog: true
tags:
    - algorithm
---
**相关代码已经托管到github上，欢迎指正bug.[戳我](https://github.com/WantUzZ/Algorithm-implementation)**
## 排序
#### 冒泡
冒泡排序，就跟它的名字一样，你可以想想一条🐟现在在一个湖底。鱼肚子里面是我们将要排序的数据。这个鱼每隔一段时间会打个嗝（吐个泡泡），而这个泡泡中的数总是鱼肚子里面的最大值或者最小值。然后一个小朋友在岸上拿了一个泡泡收集器，把它吐出的泡泡一个一个按顺序放进机器里面。最后整个泡泡收集器中的数据都是有序的了。
```javascript
for(let i = 0 ;i < 待排序数组(a)的长度;i++){
    for(let j = 0;j<待排序数组(a)的长度-1-i;j++){
        if(a[j]>a[j+1]){
            let temp = a[j];
            a[j] = a[j+1];
            a[j+1] = a[j];
        }
    }
}
```
第一层for循环就是把鱼肚子里面的最大数吐出去。<br>
第二层循环就是一个泡泡上升（不断交换）的过程。<br>
时间复杂度：O(n*n)

#### （二分）插入排序
插入排序有一个前提：就是已经存在了一个已经排好顺序的数组了，这个时候我们在不断的将新的数插入到这个数组的过程。
二分策略（二分查找也是基于这种策略）：小时候玩的游戏--猜价格。一件商品让你猜价格。100？高了。这个时候再猜50？低了，再猜75...整个策略就是下一次取值总是取区间的中间位的数值。
查找的时间复杂度：O（nLog2^n）以2为底n的对数
平均时间复杂度：O(n*n)
#### 堆排序
基于堆这中数据结构弄的一个排序。
堆：有点像一个完全二叉树。一般分为小根堆大根堆。小根堆就是根节点放整个堆的最小值咯。同理大根堆你懂得。
堆的几个操作：
> 上浮 

如果当前节点和它的父节点进行比较，如果这是一颗小根堆。如果存在当前节点比它的父节点小的情况，交换它们的位置。
> 下沉

如果小根堆中的父节点（如果有子节点）由于某种原因（经历过上浮操作被换到父节点这个位置或者是经历过...）大于它左右两个子节点，那么请交换它和左右两个子节点中最小的那个节点。
> 插入

每次把新添加的元素添加到最后一个节点位置，再让它进行上浮操作。
> 弹出

一种思想：将堆最上层（1号节点）的节点同最后一号位的节点进行交换，然后对1号节点进行下沉操作。
#### 快速排序

## 堆

## 栈

## 图
#### DFS

#### BFS

#### Dijkstra

#### Floyd

## 树
#### 线段树



