---
layout: post
title: "MongoDB使用整理（Doing）"
subtitle: ""
date: 2019-08-08 22:09:00
author: "wantu"
header-img: "img/mongodb_bg.jpg"
catalog: true
tags:
  - 数据库
  - MongoDB
---

MongoDB 是非关系型数据库的典型。官网对它的描述是：基于分布式文件存储的数据库，其拥有高性能、可扩展、易部署、易使用，存储数据非常方便等优势。<br>

优势：<br>
1、文档型NoSQL数据库。数据以文档的形式在MongoDB中保存，文档实际就是JSON字符串，JSON字符串容易阅读，且主流的计算机语言对其有很好的支持。<br>
2、基于文档的灵活的数据模式。相比MySQL，无需使用DDL对表结构进行修改。<br>
3、强大的索引能力。支持一级、二级、TTL索引和地理位置索引等。<br>
4、强大的扩展能力。分片机制用于实现业务的水平扩展，每个分片只保留业务的部分数据，并且支持副本集，确保分片上的数据的高可用性。<br>

## 解决什么问题

1、敏捷迭代的业务，需求变动频繁，数据模型无法确定。<br>
2、存储的数据格式灵活，不固定 ，或属于半结构化数据。<br>
3、对数据高可用性有高要求。<br>
4、需要大量的地理位置查询、文本查询。<br>
5、无需跨文档或跨表的事物及复杂的join查询支持。（4.0之后支持多文档事物，多文档事物可以理解为关系型数据库的多行事物。）<br>

## 内容

#### CURD 简诉

其查询语法跟 MySQL 的 SQL 是存在很大区别的。个人在刚刚开始写的时候感觉很难记。其实它的查询语法异常简单。后面会想起来感觉所接触到的几个非关系型数据都是这个套路，即查询语句中的条件跟存储的数据的数据结构是一样的，只需要将条件放置到相关位置进行一一对上位即可。

举例：

```
documents:
[
    {
        name:'want',
        age:23,
        hobby:['chang', 'tiao', 'rap', 'lanqiu'],
        girlfriend: null
    },
    {
        name:'haixing',
        age:23,
        hobby:['game', 'eat', 'study', 'acm'],
        girlfriend: ObjectId("2323231231")
    },
    {
        name:'xuejun',
        age:23,
        hobby:['reading', 'study'],
        girlfriend: null
    },
    {
        name:'xidada',
        age:23,
        hobby:['reading', 'game'],
        girlfriend: null
    }
]
```

查询的时候比方说要查年龄大于 22 并且喜欢的学习（study）的人。

```
db.getCollection.user.find({})。find中的{}就是我们要匹配的文档。
那么我们将条件进行填充即可。
{
    age:{ $gt:22},
    hobby:'study' //因为hobby是数组，也可以这么限定：hobby:{$in:['study']}
}
```

查询条件默认是&&的逻辑，如果想用或的逻辑使用 **\$or** 挂到查询对象上。

```javascript
{
  $or: [{ age: { $gt: 20 }, age: { $lt: 10 } }],
  hobby:'study'
}

等同与MySQL中的 where hobby = 'study' and (age > 20 or age < 10);
```

更、删、增自个查官方文档吧。

#### 索引的问题

由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。
如果索引的大小大于内存的限制，MongoDB 会删除一些索引，这将导致性能下降。

检测是否使用索引：explain 关键字。

索引的最大范围：
* 1、集合中索引不能超过 64 个
* 2、索引名的长度不能超过 128 个字符
* 3、一个复合索引最多可以有 31 个字段

刚刚开始建 schema 的时候没必要过多的索引的，后面有需要再建索引。<br>

mongoose创建索引：
```javascript
//_id自带索引
model.index({ field : 1 }); // 1为指定按升序创建索引，-1为降序创建索引。
model.index({ field : 1, fieldB : -1 });//多字段索引
```
可选参数列表：
![可选参数](/img/indexOpt.png)
#### tips
> 选至《深入学习MongDB》

1、取最值的方式：a、通过聚合然后使用一些提供的方法拿 b、[推荐使用]对某个字段进行排序然后取第一个。<br>
2、索引一般用在返回结果总是总体数据的一小部分的时候。一旦返回的数据较大（举例：超过了集合的一半）就不要用索引了。<br>
3、可以使用 $natural 来禁用掉索引。<br>
4、建立分级文档加快扫描（实际用的不多感觉）。<br>
5、AND 型查询，查询条件越苛刻（匹配最少数据量的条件）越放在前面，减少数据量。<br>
6、OR 型查询，查询条件越宽泛（匹配最多数据量的条件）越放在前面。<br>
7、在collection在256G之前进行分片

#### 聚合
###### 关联表
通过3.2版本的新功能$lookup来进行。<br>
语法：
```
{
   $lookup:
     {
       from: <collection to join>, //指定要执行联结的集合
       localField: <field from the input documents>, // 
       foreignField: <field from the documents of the "from" collection>, //指定from文档中的字段
       as: <output array field> //指定要添加到输入文档中的新数组字段的名称。
     }
}

```


例子：
```
const res = await models.Xxx.aggregate([
    { $match: query },
    { $group: { _id: '$tags' } },
    { $lookup: { from: 'tags', localField: '_id', foreignField: '_id', as: 'tags' } },
    // 关联后再做筛选
    { $match: { 'tags.name': { $all: tags_arr } } },
    { $project: { _id: 1 } },
]);
```
如果你使用的ORM的包是mongoose的话，请使用Query的populate方法。相关使用详情参阅：[文档](https://mongoosejs.com/docs/api/query.html#query_Query-populate)



#### MongoDB和关系型数据库的核心区别
核心区别就是：文档模型。<br>
关系模型需要我们把一个数据对象拆分成许多个单项。然后存到各个相应的表中，需要的时候通过查询将所需要的数据从各个表中查询出来。<br>

MongoDB的文档模式。文档模式存储单位是一个文档，可以支持数组和嵌套文档。在MongoDB中利用富文档的性质，很多时候，关联是一个伪需求，可以通过合理建模来避免。<br>

文档模型的优点：<br>
1、效率高。文档模型将数据集中到来一起，在普通机械盘中不需要在额外的移动磁头。<br>
2、可扩展性强。如果不考虑关联，数据分区分库，水平扩展简单。<br>
3、动态模式。文档模型支持可变数据模式，不要求每个文档都要有一样的数据结构，对很多异构数据场景支持较好。<br>
4、模型自然。最为接近对象模型。<br>

文档模式设计的基本策略：<br>
一般先考虑内嵌，一般的一对一、一对多关系都可以放在一个文档中使用内嵌进行解决。<br>
实在不行使用引用，即在主表中存储一个ID值指向另一张表的的ID值，从性能上来说我们一般需要两次以上的查询才能把相关的数据取到。<br>
更加重要的是MongoDB暂时还不支持跨表的事务，所以对强事务场景需要谨慎使用。（4.0版本发布后MongoDB支持原生的事务操作）<br>


