<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家 | 王涛，Web & Mobile Lover，Software Engineer，UX Designer | 这里是 @want王涛 的个人博客，与你一起发现更大的世界。">
    <meta name="keywords"  content="王涛, want王涛, want, huxpro, @huxpro, 王涛的博客, Hux Blog, 博客, 个人网站, 互联网, Web, JavaScript, 大数据">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="回顾ElasticSearch的使用 - 老王 | want">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="前言
写在最前面
  官方文档
  中文文档翻译
  es更新速度很快，最好的学习方法就是跟着官方文档走！！！
es背景故事
  多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。
在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。
直接基于Lucene工作会比较困难，所以Shay开始抽象Luce...">
    
    <meta property="article:published_time" content="2018-10-17T02:43:00Z">
    
    
    <meta property="article:author" content="wantu">
    
    
    <meta property="article:tag" content="ElasticSearch">
    
    <meta property="article:tag" content="搜索">
    
    <meta property="article:tag" content="数据分析">
    
    
    <meta property="og:image" content="http://localhost:4000/img/wantu.jpg">
    <meta property="og:url" content="http://localhost:4000/2018/10/17/elasticSearchQuery/">
    <meta property="og:site_name" content="老王 | want">
    
    <title>回顾ElasticSearch的使用 - 老王 | want</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2018/10/17/elasticSearchQuery/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


  <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    //新增访问次数
    function addCount(Counter) {
      // 页面（博客文章）中的信息：leancloud_visitors
      // id为page.url， data-flag-title为page.title
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      // 只根据文章的url查询LeanCloud服务器中的数据
      query.equalTo("post_url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("visited_times");// 将点击次数加1
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                var newTimes = counter.get('visited_times');
                $element.find('.leancloud-visitors-count').text(newTimes);
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            // 执行这里，说明LeanCloud中还没有记录此文章
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("post_title", title);// 把文章标题
            newcounter.set("post_url", url); // 文章url
            newcounter.set("visited_times", 1); // 初始点击次数：1次
            newcounter.save(null, { // 上传到LeanCloud服务器中
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                var newTimes = newcounter.get('visited_times');
                $element.find('.leancloud-visitors-count').text(newTimes);
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    //仅根据url和title查出当前访问次数，不做+1操作
    function showCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      // 只根据文章的url查询LeanCloud服务器中的数据
      query.equalTo("post_url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章
            var counter = results[0];
            var $element = $(document.getElementById(url));
            var newTimes = counter.get('visited_times');
            $element.find('.leancloud-visitors-count').text(newTimes);
          } else {
            //如果表里没查到记录，那就是异常情况了
            console.log('异常情况，不应该没记录的');
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    //调用API获取IP
    function getVisitorIpAndJudge() {
      var ip;
      var options = {
        type: 'POST',
        dataType: "json",
        //async: false, //jquery3中可以直接使用回调函数，不用再指定async
        url: "https://freegeoip.net/json/?callback=?"
      };
      $.ajax(options)
      .done(function(data, textStatus, jqXHR) {
        if(textStatus == "success") {
          ip = data.ip;
        }
        judgeVisitor(ip)
      });
    }

    //判断访客是否已访问过该文章，及访问时间，符合条件则增加一次访问次数
    function judgeVisitor(ip) {
      var Counter = AV.Object.extend("visited_times");
      var Visitor = AV.Object.extend("visitors_record");

      var $postInfo = $(".leancloud_visitors");
      var post_url = $postInfo.attr('id').trim();

      var query = new AV.Query(Visitor);

      query.equalTo("visitor_ip", ip);
      query.equalTo("post_url", post_url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            console.log('该IP已访问过该文章');

            var oldVisitor = results[0];

            var lastTime = oldVisitor.updatedAt;
            var curTime = new Date();

            var timePassed = curTime.getTime() - lastTime.getTime();

            if(timePassed > 1 * 60 * 1000) {
              console.log('距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数');

              addCount(Counter);

              oldVisitor.fetchWhenSave(true);
              oldVisitor.save(null, {
                success: function(oldVisitor) { },
                error: function(oldVisitor, error) {
                  console.log('Failed to save visitor record, with error message: ' + error.message);
                }
              });
            } else {
              console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数');
              showCount(Counter);
            }
          } else {
            console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数');

            addCount(Counter);

            var newVisitor = new Visitor();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newVisitor.setACL(acl);
            newVisitor.set("visitor_ip", ip);
            newVisitor.set("post_url", post_url);
            newVisitor.save(null, { // 上传到LeanCloud服务器中
              success: function(newVisitor) { },
              error: function(newVisitor, error) {
                console.log('Failed to create visitor record, with error message: ' + error.message);
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
          addCount(Counter);
        }
      });
    }

    $(function() {
      if ($('.leancloud_visitors').length == 1) {
        // 文章页面，调用判断方法，对符合条件的访问增加访问次数
        getVisitorIpAndJudge();
      } else if ($('.post-link').length > 1){
        // 首页 暂未使用
        // showHitCount(Counter);
      }
    });
  </script>

<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">want</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    <li>
                        <a href="/portfolio/">你好</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-universe.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-universe.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=ElasticSearch" title="ElasticSearch">ElasticSearch</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%90%9C%E7%B4%A2" title="搜索">搜索</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" title="数据分析">数据分析</a>
                        
                    </div>
                    <h1>回顾ElasticSearch的使用</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by wantu on October 17, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>





<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

                <h2 id="前言">前言</h2>
<h4 id="写在最前面">写在最前面</h4>
<p>  <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">官方文档</a><br />
  <a href="https://scsundefined.gitbooks.io/elasticsearch-reference-cn/content/">中文文档翻译</a><br />
  <strong>es更新速度很快，最好的学习方法就是跟着官方文档走！！！</strong></p>
<h4 id="es背景故事">es背景故事</h4>
<p>  多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。
在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。
直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。
后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。
然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。<br />
  第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。
一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。<br />
  Shay的妻子依旧等待着她的食谱搜索……</p>
<h4 id="基础知识">基础知识：</h4>
<p>1、es本质上是一个分布式文档(document)数据库，允许多台机器协同工作，每台机器可以运行多个es实例。单个es实例称之为节点。一组节点构成一个集群。<br />
2、索引(index)就是一批有着相似文档特征的文档的集合,集群对索引的个数没有限制。<br />
3、类型(type)在一个索引中，我们可以定义一个或者多个类型，类型是索引的一个逻辑分割。<br />
4、文档(document)是被索引的数据信息的一个基本单元。<br />
5、index:type = 1:n type:document = 1:n 但是6.x版本只允许每个index包含一个Type。<br />
6、因为单节点（硬件限制）不可能存储太大的数据量，es提供了将index（一组document的集合）划分为分片的功能。分片数据只是整个index数据的一部分，每个分片在自身内部都是一个有着完整功能并且独立的“索引”，可以被托管到集群中的任意一个节点中,而一个分片(shard)又包含多个segments，而每一个segment是一个倒排索引，每针对一个shard的查询操作都将被归于对该shard中的segment的查询。<br />
7、index 分片 复制分片关系：index划分为多个分片每个分片占整个数据的1/n，index一旦复制就会有复制分片。<br />
主分片的数量只能在创建的时候指定后期不能修改，复制分片的数量是支持后期修改的<br />
8、默认情况下es会为每一个index分配5个主分片和一个副本（5个复制分片）,但是最好是根据实际数据量手动进行设置。同一份shard是不会在一个节点中保存的(容灾、提高查询性能考量)。<br />
9、NRT近实时。从我们对一个文档进行创建索引开始到这个文档变得可以被搜索之间可能有一个潜在的传输延迟时间（默认是1秒）。<br /></p>

<h2 id="tips">tips</h2>
<h4 id="读写模型">读写模型</h4>
<p><img src="/img/writeModel.png" alt="写模型" />
那么写的时候发生问题了？<br />
在主服务器本身发生故障的情况下，托管主服务器的节点将向主服务器发送有关它的消息。<br />（1）索引操作将等待（默认情况下最多1分钟），以便主服务器将其中一个副本提升为新的主数据库。然后，<br />（2、）该操作将被转发到新的主要处理。请注意，主服务器还会监控节点的运行状况，<br />并可能（3、）决定主动降级主服务器。
<br />（4、）新的主服务器发出删除所有错误分片命令<br />（5、）所有错误分片删除ACK传回主服务器。<br />（6、）请求将被路由到新的主服务器上</p>

<h4 id="结构化查询or结构化过滤">结构化查询or结构化过滤？</h4>
<p>  最近负责的项目开始的时候并不觉得这两者有何不同，所以在项目的开始阶段无论需求是啥，一律采用结构化
查询方式去进行相关的数据的检索。但是后来回顾的时候发现这样的行为是不符合规范的。两者的侧重点不一样查询语句做全
文搜索或者其他需要进行相关性评分的时候是可以的因为_score会给一个评分，可以通过这个评分筛出最符合要求的数据
但是如果只是检索范围数据或者是满足部分条件的数据我们更应该去使用结构化过滤查询语句。（完全的使用过滤也是行不通，不指定范围的话默默认使用match_all）<br />
值得注意的是过滤查询语句执行之后返回的结果汇总是包含一个_score，但是这个分值是由match_all产生的，所有文档的得分都是1。</p>
<blockquote>
  <p>请尽可能多的去使用过滤器，尽可能多的去使用过滤查询语句。</p>
</blockquote>

<p><strong>性能相关:</strong> 
   使用过滤语句得到的是一个结果集–简单的documen列表，快速匹配运算并存入内存是十分方便的， 每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。查询语句不仅要查找相匹配的document还得计算每个document的相关性，所以一般查询语句的性能要低于过滤语句的，并且查询语句的结果也是不可缓存的。但是，由于倒排索引的缘故，一个只匹配少量文档的简单查询语句在百万级文档中的查询效率会与一条经过缓存 的过滤语句旗鼓相当，甚至略占上风。但是一般情况下，一条经过缓存的过滤查询要远胜一条查询语句的执行效率。
<strong>标准语法:</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="nx">GET</span> <span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> 
    <span class="dl">"</span><span class="s2">bool</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> 
      <span class="dl">"</span><span class="s2">must</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="dl">"</span><span class="s2">match</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">title</span><span class="dl">"</span><span class="p">:</span>   <span class="dl">"</span><span class="s2">Search</span><span class="dl">"</span>        <span class="p">}},</span> 
        <span class="p">{</span> <span class="dl">"</span><span class="s2">match</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">content</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Elasticsearch</span><span class="dl">"</span> <span class="p">}}</span>  
      <span class="p">],</span>
      <span class="dl">"</span><span class="s2">filter</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span> 
        <span class="p">{</span> <span class="dl">"</span><span class="s2">term</span><span class="dl">"</span><span class="p">:</span>  <span class="p">{</span> <span class="dl">"</span><span class="s2">status</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">published</span><span class="dl">"</span> <span class="p">}},</span> 
        <span class="p">{</span> <span class="dl">"</span><span class="s2">range</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">publish_date</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">gte</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2015-01-01</span><span class="dl">"</span> <span class="p">}}}</span> 
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="关于mustshouldmust_not组合关系的一些说明">关于must、should、must_not组合关系的一些说明</h4>

<p>must:取多个条件筛出的数据集的交集。被查询的文档一定要被包含。<br />
should:取出多个条件的数据集的并集。被查询的文档不一定要被包含，有的话文档的相关性会加分。<br />
must_not:查询文档一定不能被包含。<br /></p>

<p>一些常见的组合：<br />
  must和should:首先会筛选出所有满足must条件的文档集，如果文档集中存在满足should的文档那么加分，不存在满足should的文档还是会返回全部满足must条件的文档集。<br />
  filter和其他(must/should/must_not)：第一步还是会晒出满足过滤条件的文档集。继而在匹配满足其他条件的文档集。如果没有满足其他条件的文档集(should)就返回全部满足过滤条件的文档集,(must)就不返回任何文档<br />
  打个比方：一个dsl过滤得到全部都是江西的男性。dsl查询中must是年龄大于200的人员姓名。很明显没有满足条件的人，那么将没有返回。但是如果是dsl查询中should是年龄大于200的人员姓名，那么将返回全部的江西的男性。<br /></p>

<h4 id="过滤器性能优化">过滤器性能优化</h4>
<p>从上面的分析来看，过滤的性能大体上是好于查询的，但是过滤也有好坏。一般来说在bool条件中过滤器的顺序对性能有很大的影响。从MySQL查询优化中我们知道尽早的缩小结果集是一个非常有效的提高查询性能的方法，
同理在es中更详细的过滤条件应该被更早的去执行以便更早的排除更多的文档。<br />
<strong>控制缓存</strong><br />
缓存的过滤器非常快，所以它们需要被放在不能缓存的过滤器之前执行。</p>

<h4 id="nrtrefreshflush操作">NRT！refresh、flush操作。</h4>
<p>之前负责一个数据转换模块的编码工作，在业务逻辑理的非常清楚之后，数据转换的结果还是不尽如人意。<br />
业务大致：O–&gt;A–&gt;B<br />
数据源是O,每处理一个O的元数据会将相关的数据录入到ES中A的index,同时会发送一个消息给B系统。B从A录入到ES的index检索数据，经过一系列操作之后将产生的数据录入到ES中B的index。<br />
在B录入数据的过程中发现同样一个dsl不同时间查询的数据量是不一样的。<br />
原因是：<br />
搜索系统的Index一般都是NRT（Near Real Time），近实时的，比如Elasticsearch中，Index的实时性是由refresh控制的，默认是1s，最快可到100ms，那么也就意味着Index doc成功后，需要等待一秒钟后才可以被搜索到。<br />
什么是refresh？<br />
先将index-buffer中文档解析完成的segment写入到filesystem cache之中，这样避免了比较损耗性能io操作，又可以使document可以被搜索。这个从index-buffer中取数据到filesystem cache中的过程叫作refresh。<br />
index-buffer:缓存新数据的地方。当其满了或者refresh/flush interval到了，就会以segment file的形式写入到filesystem cache并最终写入到磁盘。默认是 10%heap size。<br />
<a href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-indices-refresh">REFRESH-API</a> <br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>POST /twitter/_refresh  指定刷新Twitter
POST /kimchy,elasticsearch/_refresh 刷新多个
POST /_refresh 全部刷新
</pre></td></tr></tbody></table></code></pre></div></div>
<p>flush:<br />
如果数据在filesystem cache之中是很有可能因为意外的故障导致丢失。此时需要一种机制，可以将对es的操作记录下来，来确保当出现故障的时候，保留在filesystem的数据不会丢失，并在重启的时候恢复过来。es为每一个shard提供来translog来记录这些操作。<br />
当向es发送创建document索引请求的时候，document数据先会进入到index buffer，与此同时会被记录到translog中，当发生refresh时（数据从index buffer流到filesystem cache的过程）translog中的操作记录不会消失，而是当数据从filesystem cache中被写入到磁盘之后才会被translog中清空。而filesystem cache写入到磁盘的过程就是flush。
<img src="/img/NRT.png" alt="NRT" /></p>

<h4 id="索引别名的实用性">索引别名的实用性</h4>
<p>  最近分析系统的数据源和采集系统数据源数据结构不一致问题牵出了这个问题。周知索引一旦建立就不能修改其mapping，但是如果需求方确实要进行相关的mapping修改那怎么办？只得重建索引然后再把数据进行导入。这个过程很可能造成服务的中断。别名就能大大缓解这个问题。<br />
索引别名相当于一个指针，只不过这个指针可以指向一个或多个索引。</p>

<p><strong>相关语法（局部）：</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="c1">//新增索引别名</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">_aliases</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">actions</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="dl">"</span><span class="s2">add</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">index</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">test1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">alias</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">alias1</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="err">或者是：</span><span class="nx">PUT</span> <span class="o">/</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span><span class="sr">/_alias/</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span>

<span class="c1">//移除索引别名</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">_aliases</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">actions</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="dl">"</span><span class="s2">remove</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">index</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">test1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">alias</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">alias1</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="c1">//重命名索引别名，此操作是原子操作。</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">_aliases</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">actions</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="dl">"</span><span class="s2">remove</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">index</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">test1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">alias</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">alias1</span><span class="dl">"</span> <span class="p">}</span> <span class="p">},</span>
        <span class="p">{</span> <span class="dl">"</span><span class="s2">add</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">index</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">test2</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">alias</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">alias1</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="fromsize的不足和深分页的解决方法">from+size的不足和深分页的解决方法</h4>
<p>  es进行后端分页常用的方法是使用from+size的那种方式进行，一旦页数比较大，那么由于分布式搜索的缘故会导致CPU和内存的大量消耗。<br />
<strong>分布式搜索解析</strong><br />
<em>第一阶段：查询阶段（解决取谁这个问题)</em><br /></p>
<ul>
  <li>客户端发送搜索请求给某个节点A（协调节点），该节点创建一个from+size的空优先级队列。</li>
  <li>节点A转发这个搜索请求到索引中的每个分片的原本或副本，每个分片在本地执行这个查询并且会将结果保存到一个大小为from+size的有*序本地优先级队列中。</li>
  <li>每个分片返回document的ID和它的优先级队列的所有document的排序值给协调节点A,节点A会把这些值合并到自己的优先级队列里产生全局排序结果。<br /></li>
</ul>

<p><em>第二阶段：取回阶段（解决取的是谁这个问题)</em><br /></p>
<ul>
  <li>协调节点会根据全局排序结果辨别出哪个document需要取回，并且向相关的分片发送GET请求。</li>
  <li>每个分片加载document并且根据需要丰富它们（丰富：补全一些必要的信息），然后将document返回给协调节点。</li>
  <li>一旦所有的document都被取回，协调节点会将返回结果返回给客户端。</li>
</ul>

<p>根据上面的对分布式搜索的认知我们知道使用from+size的这种方式进行分页操作，每个分片都要构造一个from+size长度的优先级队列，而协调节点则要对  分片数量*（from+size） 个document进行排序找size个document。这就是消耗CPU和内存的原因了。而且在实际工作中会出现from+size查询10000以后数据为空的情况（在网上还发现部分出现报错提示）。</p>

<p><strong>解决</strong><br />
1、通过修改index.max_result_window的值来继续使用from+size。但是对内存的占用很大。不推荐。
2、使用scroll API做深度分页。
3、使用search_after API。</p>

<p><strong>scroll做深度分页</strong><br />
直接上DSL</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="p">(</span><span class="err">通过</span><span class="nx">API</span><span class="err">调用</span><span class="nx">search</span><span class="err">方法</span><span class="p">)</span><span class="err">：</span>
<span class="p">{</span>
	<span class="dl">"</span><span class="s2">index</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">chat</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">from</span><span class="dl">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">5m</span><span class="dl">"</span><span class="p">,</span><span class="c1">//5分钟之后失效</span>
	<span class="dl">"</span><span class="s2">body</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
		<span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">:</span> <span class="p">{},</span>
		<span class="dl">"</span><span class="s2">sort</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
			<span class="dl">"</span><span class="s2">time</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">desc</span><span class="dl">"</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="p">(</span><span class="nx">elasticsearch</span><span class="o">-</span><span class="nx">head</span><span class="err">中使用</span><span class="p">)</span>
<span class="nx">GET</span><span class="p">:</span> <span class="o">/</span><span class="nx">index</span><span class="o">/</span><span class="nx">_search</span><span class="p">?</span><span class="nx">scroll</span> <span class="o">=</span> <span class="mi">10</span><span class="nx">m</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">match_all</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="dl">"</span><span class="s2">sort</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">_doc</span><span class="dl">"</span><span class="p">],</span> 
    <span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span>  <span class="mi">1000</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>scroll分页请求头必须携带一个scroll属性，表示scroll的失效时间。第一次请求之后会除了数据还有一个scroll_id返回回来，接下来的请求我们只需要将scroll和scroll_id作为请求参数就可以不停的获取下一批数据。scrollId在失效时间内是存在的，但是es维护它是需要额外的开销的，好习惯：每次查询结束进行手动的清除scrollId.<br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>DELETE /_search/scroll
{
    "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>js:<a href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-scroll">API</a><br /></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">client</span><span class="p">.</span><span class="nx">clearScroll</span><span class="p">([</span><span class="nx">params</span><span class="p">,</span> <span class="p">[</span><span class="nx">callback</span><span class="p">]])</span><span class="c1">//Params中的scrollId属性的值可以是：String, String[], Boolean</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>code(xxx.iced)</strong><br /></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre><span class="c1">// 刚开始的一次scroll查询</span>
  <span class="nx">searchRBN</span><span class="p">:</span> <span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span><span class="o">-&gt;</span>
    <span class="nx">dsl</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">cloneDeep</span> <span class="nx">DSL</span><span class="p">.</span><span class="nx">COMMUNICATION_RECORD_BETWEEN_NODES</span>
    <span class="nx">dsl</span><span class="p">.</span><span class="nx">index</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">index</span>
    <span class="k">if</span> <span class="nx">query</span><span class="p">.</span><span class="nx">sort</span> <span class="nx">and</span> <span class="nx">query</span><span class="p">.</span><span class="nx">sort</span> <span class="nx">is</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span>
      <span class="nx">dsl</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">sort</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">time</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span>

    <span class="nx">dsl</span><span class="p">.</span><span class="nx">scroll</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">scroll</span> <span class="k">if</span> <span class="nx">query</span><span class="p">.</span><span class="nx">scroll</span>
    <span class="nx">dsl</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">bool</span><span class="p">.</span><span class="nx">should</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">bool</span><span class="p">.</span><span class="nx">must</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">term</span><span class="p">.</span><span class="nx">source</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">source</span>
    <span class="nx">dsl</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">bool</span><span class="p">.</span><span class="nx">should</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">bool</span><span class="p">.</span><span class="nx">must</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">term</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">target</span>
    <span class="nx">dsl</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">bool</span><span class="p">.</span><span class="nx">should</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">bool</span><span class="p">.</span><span class="nx">must</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">term</span><span class="p">.</span><span class="nx">source</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">target</span>
    <span class="nx">dsl</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">bool</span><span class="p">.</span><span class="nx">should</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">bool</span><span class="p">.</span><span class="nx">must</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">term</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">source</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">info</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span> <span class="nx">dsl</span>
    <span class="nx">allHits</span> <span class="o">=</span> <span class="p">[]</span>    
    <span class="nx">esClient</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">dsl</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span><span class="o">-&gt;</span> 
        <span class="nx">response</span><span class="p">.</span><span class="nx">hits</span><span class="p">.</span><span class="nx">hits</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">hit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">allHits</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">hit</span><span class="p">))</span>
        <span class="nx">objArr</span> <span class="o">=</span> <span class="nx">buildRBNSData</span> <span class="nx">allHits</span>
        <span class="k">return</span> <span class="nx">objArr</span>
      <span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">result</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span><span class="o">-&gt;</span>
        <span class="nx">cb</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">result</span>
      <span class="p">)</span>
  <span class="c1">//查询下一页接口     </span>
  <span class="nx">searchRBNScrollData</span><span class="p">:(</span><span class="nx">query</span><span class="p">,</span><span class="nx">callback</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nx">sq</span> <span class="o">=</span> <span class="p">{</span><span class="na">scroll_id</span><span class="p">:</span> <span class="nx">query</span><span class="p">.</span><span class="nx">scrollId</span><span class="p">,</span> <span class="na">scroll</span><span class="p">:</span> <span class="nx">query</span><span class="p">.</span><span class="nx">scroll</span><span class="p">}</span> 
    <span class="nx">esClient</span><span class="p">.</span><span class="nx">scroll</span><span class="p">(</span><span class="nx">sq</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">-&gt;</span> 
      <span class="nx">callback</span> <span class="kc">null</span><span class="p">,</span><span class="nx">buildRBNSData</span> <span class="nx">response</span><span class="p">.</span><span class="nx">hits</span><span class="p">.</span><span class="nx">hits</span>
    <span class="p">).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">-&gt;</span> 
      <span class="nx">callback</span> <span class="nx">error</span>
    <span class="p">)</span>
  <span class="c1">//组装数据</span>
  <span class="nx">buildRBNSData</span> <span class="o">=</span> <span class="p">(</span><span class="nx">dataArr</span><span class="p">)</span><span class="o">-&gt;</span>
    <span class="nx">objArr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">dataArr</span>
      <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_id</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">source</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">source</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">target</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">type</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">time</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">time</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">content</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_source</span><span class="p">.</span><span class="nx">content</span>
      <span class="nx">objArr</span><span class="p">.</span><span class="nx">push</span> <span class="nx">obj</span>
    <span class="k">return</span> <span class="nx">objArr</span> 
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>scroll API的不足</strong><br />
  虽然es官方文档中也建议我们使用scroll API进行高效的深度滚动，但是使用scroll context的花费是很高的，建议不要将其用在用户实时请求上。那么实时请求的处理可以交给search_after。</p>

<p><strong>search_after API做深度分页</strong><br />
  search_after参数通过提供实时的游标来解决这个问题。它的策略是使用上一页的结果来帮助检索下一页。值得注意的是：分页的前提是对数据集进行排序，涉及排序需要将文档中的某一个字段作为排序依据。那个字段必须是能够标识某一个文档的，否则具有相同值的文档的顺序将无法确定。建议使用字段_id因为它是每一个文档的唯一值。search_after是实时的，它始终针对最新版本的搜索器进行解析。它也不是解决自由跳转的方案。因为是实时的所以排序顺序可能会在索引更新或者删除的时候发生变化。<br />
先模拟查询一次：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="nx">GET</span> <span class="nx">twitter</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">match</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span>
            <span class="dl">"</span><span class="s2">title</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">elasticsearch</span><span class="dl">"</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="dl">"</span><span class="s2">sort</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="dl">"</span><span class="s2">date</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">asc</span><span class="dl">"</span><span class="p">},</span>
        <span class="p">{</span><span class="dl">"</span><span class="s2">_id</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">desc</span><span class="dl">"</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>模拟获取下一页数据：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="nx">GET</span> <span class="nx">twitter</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
    <span class="dl">"</span><span class="s2">size</span><span class="dl">"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">match</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span>
            <span class="dl">"</span><span class="s2">title</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">elasticsearch</span><span class="dl">"</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="dl">"</span><span class="s2">search_after</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1463538857</span><span class="p">,</span> <span class="dl">"</span><span class="s2">654323</span><span class="dl">"</span><span class="p">],</span>
    <span class="dl">"</span><span class="s2">sort</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="dl">"</span><span class="s2">date</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">asc</span><span class="dl">"</span><span class="p">},</span>
        <span class="p">{</span><span class="dl">"</span><span class="s2">_id</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">desc</span><span class="dl">"</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="c1">//search_afetr就是根据你的sort排序规则，填写上一次获取的最后一个数据的值，我们第一次查的是按照date、_id排序，所以填写上次获取的最后一个数据的date和_id即可。</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="问题">问题</h2>
<h4 id="为啥主分片的数量后期无法修改">为啥主分片的数量后期无法修改？</h4>
<p>es通过以下公式计算文档对应的分片：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>shard = hash(routing) % number_of_primary_shards
//routing 默认是文档的id
//number_of_primary_shards 主分片的数量
</pre></td></tr></tbody></table></code></pre></div></div>
<p>从这个公式可以看出如果主分片数量发生改变很有可能造成文档对应的分片找不到的情况。</p>
<h4 id="脑裂问题">脑裂问题</h4>

                
                
                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/10/17/bookSummary/" data-toggle="tooltip" data-placement="top" title="书摘">
                        Previous<br>
                        <span>书摘</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/10/24/buildExpressProject/" data-toggle="tooltip" data-placement="top" title="回顾搭建一个基于express的web项目遇到的问题">
                        Next<br>
                        <span>回顾搭建一个基于express的web项目遇到的问题</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        </a>
        
        
                <a data-sort="0017" 
                    href="/archive/?tag=%E4%B9%A6"
                    title="书"
                    rel="2">书
    </div>
</section>


                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>




    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/WantUzZ">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>
                <p class="copyright text-muted">
                  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span> | <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> | <span id="busuanzi_container_page_pv">本文总阅读<span id="busuanzi_value_page_pv"></span>次</span>
                   <!-- <a href="http://gfwant.com">want</a> | -->
                  <iframe
                      style="margin-left: 2px; margin-bottom:-5px;"
                      frameborder="0" scrolling="0" width="100px" height="20px"
                      src="" >
                  </iframe>
                </p>
                <p class="copyright text-muted">
                    Copyright &copy; want 2019
                     <!-- <a href="http://gfwant.com">want</a> | -->
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>
<!-- https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true -->
<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'gfwant.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->



  <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    //新增访问次数
    function addCount(Counter) {
      // 页面（博客文章）中的信息：leancloud_visitors
      // id为page.url， data-flag-title为page.title
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      // 只根据文章的url查询LeanCloud服务器中的数据
      query.equalTo("post_url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("visited_times");// 将点击次数加1
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                var newTimes = counter.get('visited_times');
                $element.find('.leancloud-visitors-count').text(newTimes);
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            // 执行这里，说明LeanCloud中还没有记录此文章
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("post_title", title);// 把文章标题
            newcounter.set("post_url", url); // 文章url
            newcounter.set("visited_times", 1); // 初始点击次数：1次
            newcounter.save(null, { // 上传到LeanCloud服务器中
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                var newTimes = newcounter.get('visited_times');
                $element.find('.leancloud-visitors-count').text(newTimes);
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    //仅根据url和title查出当前访问次数，不做+1操作
    function showCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      // 只根据文章的url查询LeanCloud服务器中的数据
      query.equalTo("post_url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章
            var counter = results[0];
            var $element = $(document.getElementById(url));
            var newTimes = counter.get('visited_times');
            $element.find('.leancloud-visitors-count').text(newTimes);
          } else {
            //如果表里没查到记录，那就是异常情况了
            console.log('异常情况，不应该没记录的');
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    //调用API获取IP
    function getVisitorIpAndJudge() {
      var ip;
      var options = {
        type: 'POST',
        dataType: "json",
        //async: false, //jquery3中可以直接使用回调函数，不用再指定async
        url: "https://freegeoip.net/json/?callback=?"
      };
      $.ajax(options)
      .done(function(data, textStatus, jqXHR) {
        if(textStatus == "success") {
          ip = data.ip;
        }
        judgeVisitor(ip)
      });
    }

    //判断访客是否已访问过该文章，及访问时间，符合条件则增加一次访问次数
    function judgeVisitor(ip) {
      var Counter = AV.Object.extend("visited_times");
      var Visitor = AV.Object.extend("visitors_record");

      var $postInfo = $(".leancloud_visitors");
      var post_url = $postInfo.attr('id').trim();

      var query = new AV.Query(Visitor);

      query.equalTo("visitor_ip", ip);
      query.equalTo("post_url", post_url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            console.log('该IP已访问过该文章');

            var oldVisitor = results[0];

            var lastTime = oldVisitor.updatedAt;
            var curTime = new Date();

            var timePassed = curTime.getTime() - lastTime.getTime();

            if(timePassed > 1 * 60 * 1000) {
              console.log('距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数');

              addCount(Counter);

              oldVisitor.fetchWhenSave(true);
              oldVisitor.save(null, {
                success: function(oldVisitor) { },
                error: function(oldVisitor, error) {
                  console.log('Failed to save visitor record, with error message: ' + error.message);
                }
              });
            } else {
              console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数');
              showCount(Counter);
            }
          } else {
            console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数');

            addCount(Counter);

            var newVisitor = new Visitor();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newVisitor.setACL(acl);
            newVisitor.set("visitor_ip", ip);
            newVisitor.set("post_url", post_url);
            newVisitor.save(null, { // 上传到LeanCloud服务器中
              success: function(newVisitor) { },
              error: function(newVisitor, error) {
                console.log('Failed to create visitor record, with error message: ' + error.message);
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
          addCount(Counter);
        }
      });
    }

    $(function() {
      if ($('.leancloud_visitors').length == 1) {
        // 文章页面，调用判断方法，对符合条件的访问增加访问次数
        getVisitorIpAndJudge();
      } else if ($('.post-link').length > 1){
        // 首页 暂未使用
        // showHitCount(Counter);
      }
    });
  </script>


<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
