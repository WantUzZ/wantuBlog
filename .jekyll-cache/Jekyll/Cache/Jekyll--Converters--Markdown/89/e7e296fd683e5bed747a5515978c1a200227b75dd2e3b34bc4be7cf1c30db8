I"XB<p>  MongoDB 是非关系型数据库的典型。官网对它的描述是：基于分布式文件存储的数据库，其拥有高性能、可扩展、易部署、易使用，存储数据非常方便等优势。<br />
本文旨在列举实际工作中常用到的一些知识点，以及其相关的扩展知识。系统的学习请参阅官方文档。<br /></p>

<p>优势：<br />
  1、文档型NoSQL数据库。数据以文档的形式在MongoDB中保存，文档实际就是JSON字符串，JSON字符串容易阅读，且主流的计算机语言对其有很好的支持。<br />
  2、基于文档的灵活的数据模式。相比MySQL，无需使用DDL对表结构进行修改。<br />
  3、强大的索引能力。支持一级、二级、TTL索引和地理位置索引等。<br />
  4、强大的扩展能力。分片机制用于实现业务的水平扩展，每个分片只保留业务的部分数据，并且支持副本集，确保分片上的数据的高可用性。<br /></p>

<h2 id="适用的业务场景">适用的业务场景</h2>

<p>  1、敏捷迭代的业务，需求变动频繁，数据模型无法确定。<br />
  2、存储的数据格式灵活，不固定 ，或属于半结构化数据。<br />
  3、对数据高可用性有高要求。<br />
  4、需要大量的地理位置查询、文本查询。<br />
  5、无需跨文档或跨表的事物及复杂的join查询支持。（4.0之后支持多文档事物，多文档事物可以理解为关系型数据库的多行事物。）<br /></p>

<h2 id="内容">内容</h2>

<h4 id="curd-简诉">CURD 简诉</h4>

<p>  其查询语法跟 MySQL 的 SQL 是存在很大区别的。个人在刚刚开始写的时候感觉很难记。其实它的查询语法异常简单。后面会想起来感觉所接触到的几个非关系型数据库都是这个套路，即查询语句中的条件跟存储的数据的数据结构高度相关。</p>

<p>举例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>documents:
[
    {
        name:'want',
        age:23,
        hobby:['chang', 'tiao', 'rap', 'lanqiu'],
        girlfriend: null
    },
    {
        name:'haixing',
        age:23,
        hobby:['game', 'eat', 'study', 'acm'],
        girlfriend: ObjectId("2323231231")
    },
    {
        name:'xuejun',
        age:23,
        hobby:['reading', 'study'],
        girlfriend: null
    },
    {
        name:'xidada',
        age:23,
        hobby:['reading', 'game'],
        girlfriend: null
    }
]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>查询的时候比方说要查年龄大于 22 并且喜欢的学习（study）的人。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>db.getCollection.user.find({})。find中的{}就是我们要匹配的文档。
那么我们将条件进行填充即可。
{
    age:{ $gt:22},
    hobby:'study' //因为hobby是数组，也可以这么限定：hobby:{$in:['study']}
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>查询条件默认是&amp;&amp;的逻辑，如果想用或的逻辑使用 <strong>$or</strong> 挂到查询对象上。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="p">{</span>
  <span class="nl">$or</span><span class="p">:</span> <span class="p">[{</span> <span class="na">age</span><span class="p">:</span> <span class="p">{</span> <span class="na">$gt</span><span class="p">:</span> <span class="mi">20</span> <span class="p">},</span> <span class="na">age</span><span class="p">:</span> <span class="p">{</span> <span class="na">$lt</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}</span> <span class="p">}],</span>
  <span class="na">hobby</span><span class="p">:</span><span class="dl">'</span><span class="s1">study</span><span class="dl">'</span>
<span class="p">}</span>

<span class="err">等同与</span><span class="nx">MySQL</span><span class="err">中的</span> <span class="nx">where</span> <span class="nx">hobby</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">study</span><span class="dl">'</span> <span class="nx">and</span> <span class="p">(</span><span class="nx">age</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="nx">or</span> <span class="nx">age</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="mongoose">mongoose</h4>
<p>  mongoose是一个node的第三方模块。</p>
<h4 id="索引的问题">索引的问题</h4>

<p>由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。
如果索引的大小大于内存的限制，MongoDB 会删除一些索引，这将导致性能下降。</p>

<p>检测是否使用索引（官方文档上写了三种方式）：<strong>explain()</strong><br />
查询计划解读<a href="https://docs.mongodb.com/manual/reference/explain-results/index.html">官方文档传送门</a>：<br />
<img src="/img/mongoExplain.png" alt="执行计划结果图" /></p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="p">-</span> queryplanner: 详细的说明了查询优化器选择的计划，queryplanner模式下并不会真正的执行query语句查询，而是针对query语句进行执行计划分析选出winning plan。
<span class="p"> -</span> namespace: query所查询的表
<span class="p"> -</span> indexFilterSet: 这个查询是否应用了索引过滤器。（看query有没有用索引不能看这个）
<span class="p"> -</span> winningplan: 查询优化器针对这次query所返回的最优执行计划的详细内容
<span class="p">  -</span> stage: 最优执行计划的stage有以下几个类型：
<span class="p">    -</span> COLLSCAN: 全表扫描
<span class="p">    -</span> IXSCAN: 索引扫描
<span class="p">    -</span> FETCH: 根据索引去检索制定文档
<span class="p">    -</span> SHARD_MERGE: 将各个分片返回数据进行merge
<span class="p">  -</span> filter: 过滤条件
<span class="p">  -</span> inputStage:
<span class="p">  -</span> keyPattern:
<span class="p">  -</span> indexName: winning plan所选用的index
<span class="p">  -</span> isMultiKey: 是否是
<span class="p">  -</span> direction: 查询顺序
<span class="p">  -</span> rejectedPlans: 其他非最优执行计划
<span class="p">-</span> executionStats
<span class="p"> -</span> executionSuccess: 是否执行成功
<span class="p"> -</span> nReturned: 返回的数据条数
<span class="p"> -</span> executionTimeMillis: 执行时间(越少越好)
<span class="p"> -</span> totalKeysExamined: 索引扫描次数
<span class="p"> -</span> totalDocsExamined: 文档扫描次数
<span class="p"> -</span> executionStages
<span class="p">  -</span> ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>索引的最大范围：</p>
<ul>
  <li>1、集合中索引不能超过 64 个</li>
  <li>2、索引名的长度不能超过 128 个字符</li>
  <li>3、一个复合索引最多可以有 31 个字段</li>
</ul>

<p>刚刚开始建 schema 的时候没必要过多的索引的，后面有需要再建索引。<br /></p>

<p>mongoose创建索引：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">//_id自带索引</span>
<span class="nx">model</span><span class="p">.</span><span class="nx">index</span><span class="p">({</span> <span class="na">field</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">});</span> <span class="c1">// 1为指定按升序创建索引，-1为降序创建索引。</span>
<span class="nx">model</span><span class="p">.</span><span class="nx">index</span><span class="p">({</span> <span class="na">field</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">fieldB</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">});</span><span class="c1">//多字段索引</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>可选参数列表：
<img src="/img/indexOpt.png" alt="可选参数" /></p>

<h4 id="高级">高级</h4>
<h6 id="关联表">关联表</h6>
<p>通过3.2版本的新功能$lookup来进行。<br />
语法：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>{
   $lookup:
     {
       from: &lt;collection to join&gt;, //指定要执行联结的集合
       localField: &lt;field from the input documents&gt;, // 
       foreignField: &lt;field from the documents of the "from" collection&gt;, //指定from文档中的字段
       as: &lt;output array field&gt; //指定要添加到输入文档中的新数组字段的名称。
     }
}

</pre></td></tr></tbody></table></code></pre></div></div>

<p>例子：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>const res = await models.Xxx.aggregate([
    { $match: query },
    { $group: { _id: '$tags' } },
    { $lookup: { from: 'tags', localField: '_id', foreignField: '_id', as: 'tags' } },
    // 关联后再做筛选
    { $match: { 'tags.name': { $all: tags_arr } } },
    { $project: { _id: 1 } },
]);
</pre></td></tr></tbody></table></code></pre></div></div>
<p>如果你使用的ORM的包是mongoose的话，请使用Query的populate方法。相关使用详情参阅：<a href="https://mongoosejs.com/docs/api/query.html#query_Query-populate">文档</a></p>

<h6 id="正则表达式">正则表达式</h6>
<p>MongoDB 使用 $regex 操作符来设置匹配字符串的正则表达式。
MongoDB使用PCRE (Perl Compatible Regular Expression) 作为正则表达式语言。
不同于全文检索（2.6 版本以后需要开启相关配置:db.adminCommand({setParameter:true,textSearchEnabled:true})），我们使用正则表达式不需要做任何配置。<br /></p>

<p>使用：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span><span class="na">post_text</span><span class="p">:{</span><span class="na">$regex</span><span class="p">:</span><span class="dl">"</span><span class="s2">xxx</span><span class="dl">"</span><span class="p">}})</span> 
<span class="err">或者</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span><span class="na">post_text</span><span class="p">:</span><span class="sr">/xxx/</span><span class="p">})</span>

<span class="c1">//不区分大小写</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span><span class="na">post_text</span><span class="p">:{</span><span class="na">$regex</span><span class="p">:</span><span class="dl">"</span><span class="s2">xxx</span><span class="dl">"</span><span class="p">,</span><span class="na">$options</span><span class="p">:</span><span class="dl">"</span><span class="s2">$i</span><span class="dl">"</span><span class="p">}})</span>

<span class="c1">// 还支持在数组字段中使用正则表达式来查找内容 tags为数组字段</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span><span class="na">tags</span><span class="p">:{</span><span class="na">$regex</span><span class="p">:</span><span class="dl">"</span><span class="s2">xxx</span><span class="dl">"</span><span class="p">}})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>注意：正则中使用变量。需要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入正则表达式。<br /></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">name</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span> <span class="o">+</span> <span class="err">变量值</span><span class="nx">key</span> <span class="o">+</span><span class="dl">"</span><span class="s2">/i</span><span class="dl">"</span><span class="p">);</span>
<span class="nl">title</span><span class="p">:</span><span class="nb">eval</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="o">+</span><span class="nx">title</span><span class="o">+</span><span class="dl">"</span><span class="s2">/i</span><span class="dl">"</span><span class="p">)</span>    <span class="c1">// 等同于 title:{$regex:title,$Option:"$i"}   </span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="相关书籍">相关书籍</h4>
<blockquote>
  <p>《深入学习MongDB》</p>
</blockquote>

<p>1、取最值的方式：a、通过聚合然后使用一些提供的方法拿 b、[推荐使用]对某个字段进行排序然后取第一个。<br />
2、索引一般用在返回结果总是总体数据的一小部分的时候。一旦返回的数据较大（举例：超过了集合的一半）就不要用索引了。<br />
3、可以使用 $natural 来禁用掉索引。<br />
4、建立分级文档加快扫描（实际用的不多感觉）。<br />
5、AND 型查询，查询条件越苛刻（匹配最少数据量的条件）越放在前面，减少数据量。<br />
6、OR 型查询，查询条件越宽泛（匹配最多数据量的条件）越放在前面。<br />
7、在collection在256G之前进行分片</p>

<h2 id="后记">后记</h2>
<h4 id="mongodb和关系型数据库的核心区别">MongoDB和关系型数据库的核心区别</h4>
<p>核心区别就是：文档模型。<br />
关系模型需要我们把一个数据对象拆分成许多个单项。然后存到各个相应的表中，需要的时候通过查询将所需要的数据从各个表中查询出来。<br /></p>

<p>MongoDB的文档模式。文档模式存储单位是一个文档，可以支持数组和嵌套文档。在MongoDB中利用富文档的性质，很多时候，关联是一个伪需求，可以通过合理建模来避免。<br /></p>

<p>文档模型的优点：<br />
1、效率高。文档模型将数据集中到来一起，在普通机械盘中不需要在额外的移动磁头。<br />
2、可扩展性强。如果不考虑关联，数据分区分库，水平扩展简单。<br />
3、动态模式。文档模型支持可变数据模式，不要求每个文档都要有一样的数据结构，对很多异构数据场景支持较好。<br />
4、模型自然。最为接近对象模型。<br /></p>

<p>文档模式设计的基本策略：<br />
一般先考虑内嵌，一般的一对一、一对多关系都可以放在一个文档中使用内嵌进行解决。<br />
实在不行使用引用，即在主表中存储一个ID值指向另一张表的的ID值，从性能上来说我们一般需要两次以上的查询才能把相关的数据取到。<br />
更加重要的是MongoDB暂时还不支持跨表的事务，所以对强事务场景需要谨慎使用。（4.0版本发布后MongoDB支持原生的事务操作）<br /></p>

:ET